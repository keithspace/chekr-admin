import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'dart:html' as html;
import 'package:shared_preferences/shared_preferences.dart';

class CustomerActivityReportPage extends StatefulWidget {
  @override
  _CustomerActivityReportPageState createState() => _CustomerActivityReportPageState();
}

class _CustomerActivityReportPageState extends State<CustomerActivityReportPage> {
  String selectedPeriod = 'All Time';
  late Future<List<Map<String, dynamic>>> customerDataFuture;
  DateTime? startDate;
  DateTime? endDate;
  String searchQuery = '';
  Map<String, dynamic>? adminInfo;

  @override
  void initState() {
    super.initState();
    customerDataFuture = fetchCustomerActivity();
    fetchAdminInfo();
  }

  Future<void> fetchAdminInfo() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    String? adminId = prefs.getString('adminId');
    if (adminId != null && adminId.isNotEmpty) {
      try {
        DocumentSnapshot adminSnapshot = await FirebaseFirestore.instance
            .collection('admins')
            .doc(adminId)
            .get();
        if (adminSnapshot.exists) {
          setState(() {
            adminInfo = adminSnapshot.data() as Map<String, dynamic>?;
          });
        }
      } catch (e) {
        print('Error fetching admin info: $e');
      }
    }
  }

  Future<List<Map<String, dynamic>>> fetchCustomerActivity() async {
    DateTime now = DateTime.now();
    DateTime startDate;

    switch (selectedPeriod) {
      case 'Daily':
        startDate = DateTime(now.year, now.month, now.day);
        break;
      case 'Weekly':
        startDate = now.subtract(Duration(days: now.weekday - 1));
        break;
      case 'Monthly':
        startDate = DateTime(now.year, now.month, 1);
        break;
      default:
        startDate = DateTime(2000);
    }

    QuerySnapshot customerSnapshot = await FirebaseFirestore.instance.collection('customers').get();
    List<Map<String, dynamic>> customers = [];

    for (var customerDoc in customerSnapshot.docs) {
      String customerId = customerDoc.id;
      Map<String, dynamic> customerInfo = customerDoc.data() as Map<String, dynamic>;

      Query orderQuery = FirebaseFirestore.instance
          .collection('orders')
          .where('userId', isEqualTo: customerId)
          .orderBy('timestamp')
          .startAt([startDate]);

      QuerySnapshot orderSnapshot = await orderQuery.get();
      int orderCount = orderSnapshot.docs.length;
      double totalSpent = orderSnapshot.docs.fold(0, (sum, doc) => sum + (doc['amount'] ?? 0));

      Query loginQuery = FirebaseFirestore.instance
          .collection('logins')
          .where('userId', isEqualTo: customerId)
          .orderBy('timestamp', descending: true)
          .limit(1);

      QuerySnapshot loginSnapshot = await loginQuery.get();
      DateTime? lastLogin = loginSnapshot.docs.isNotEmpty ? (loginSnapshot.docs.first['timestamp'] as Timestamp).toDate() : null;

      DateTime? timeRegistered = (customerInfo['timeRegistered'] as Timestamp?)?.toDate();

      customers.add({
        'name': customerInfo['name'] ?? 'Unknown',
        'email': customerInfo['email'] ?? 'No Email',
        'phone': customerInfo['phone'] ?? 'No Phone',
        'logins': loginSnapshot.docs.length,
        'orders': orderCount,
        'totalSpent': totalSpent.toStringAsFixed(2),
        'registrationDate': timeRegistered?.toString() ?? 'N/A',
        'lastLogin': lastLogin?.toString() ?? 'N/A',
      });
    }

    return customers;
  }

  Future<void> _downloadReportAsPdf() async {
    final pdf = pw.Document();
    await fetchAdminInfo();
    final customerData = await customerDataFuture;

    pdf.addPage(
      pw.Page(
        build: (pw.Context context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Text(
                'Customer Activity Report - $selectedPeriod',
                style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
              ),
              pw.SizedBox(height: 10),
              pw.Text('Chekr'),
              pw.SizedBox(height: 10),
              pw.Text('Generated by: ${adminInfo?['name'] ?? 'N/A'} (${adminInfo?['task'] ?? 'N/A'})'),
              pw.SizedBox(height: 10),
              pw.Text('Generated on: ${DateTime.now().toString()}'),
              pw.SizedBox(height: 20),
              pw.Table.fromTextArray(
                headers: ['Name', 'Email', 'Phone', 'Logins', 'Orders', 'Total Spent', 'Registration Date', 'Last Login'],
                data: customerData.map((data) {
                  return [
                    data['name'],
                    data['email'],
                    data['phone'],
                    data['logins'].toString(),
                    data['orders'].toString(),
                    'Ksh ${data['totalSpent']}',
                    data['registrationDate'],
                    data['lastLogin'],
                  ];
                }).toList(),
              ),
            ],
          );
        },
      ),
    );

    final Uint8List pdfBytes = await pdf.save();

    if (kIsWeb) {
      final blob = html.Blob([pdfBytes], 'application/pdf');
      final url = html.Url.createObjectUrlFromBlob(blob);
      final anchor = html.AnchorElement(href: url)
        ..setAttribute('download', 'customer_activity_report.pdf')
        ..click();
      html.Url.revokeObjectUrl(url);
    } else {
      await Printing.layoutPdf(
        onLayout: (PdfPageFormat format) async => pdfBytes,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final bool isDarkTheme = theme.brightness == Brightness.dark;

    return Scaffold(
      appBar: AppBar(
        title: Text('Customer Activity Report', style: TextStyle(color: Colors.white)),
        backgroundColor: isDarkTheme ? Colors.grey[900] : Colors.blue,
        elevation: 0,
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            // Filters and Search
            Row(
              children: [
                Expanded(
                  child: DropdownButton<String>(
                    value: selectedPeriod,
                    items: ['All Time', 'Daily', 'Weekly', 'Monthly']
                        .map((String value) => DropdownMenuItem<String>(
                      value: value,
                      child: Text(value),
                    )).toList(),
                    onChanged: (String? newValue) {
                      if (newValue != null) {
                        setState(() {
                          selectedPeriod = newValue;
                          customerDataFuture = fetchCustomerActivity();
                        });
                      }
                    },
                    style: TextStyle(color: isDarkTheme ? Colors.white : Colors.black),
                    dropdownColor: isDarkTheme ? Colors.grey[800] : Colors.white,
                  ),
                ),
                SizedBox(width: 10),
                Expanded(
                  child: TextField(
                    decoration: InputDecoration(
                      labelText: 'Search by Name or Email',
                      prefixIcon: Icon(Icons.search),
                    ),
                    onChanged: (value) {
                      setState(() {
                        searchQuery = value;
                      });
                    },
                  ),
                ),
              ],
            ),
            SizedBox(height: 20),
            // Download Button
            ElevatedButton.icon(
              onPressed: _downloadReportAsPdf,
              icon: Icon(Icons.download),
              label: Text('Download Report'),
              style: ElevatedButton.styleFrom(
                padding: EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
            ),
            SizedBox(height: 20),
            // Data Table
            Expanded(
              child: FutureBuilder<List<Map<String, dynamic>>>(
                future: customerDataFuture,
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return Center(child: CircularProgressIndicator());
                  } else if (snapshot.hasError) {
                    return Center(child: Text('Error: ${snapshot.error}'));
                  } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
                    return Center(child: Text('No data available'));
                  }

                  final filteredData = snapshot.data!.where((customer) {
                    final name = customer['name'].toString().toLowerCase();
                    final email = customer['email'].toString().toLowerCase();
                    return name.contains(searchQuery.toLowerCase()) || email.contains(searchQuery.toLowerCase());
                  }).toList();

                  return SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: DataTable(
                      columns: const [
                        DataColumn(label: Text('Name')),
                        DataColumn(label: Text('Email')),
                        DataColumn(label: Text('Phone')),
                        DataColumn(label: Text('Logins')),
                        DataColumn(label: Text('Orders')),
                        DataColumn(label: Text('Total Spent')),
                        DataColumn(label: Text('Registration Date')),
                        DataColumn(label: Text('Last Login')),
                      ],
                      rows: filteredData.map((data) {
                        return DataRow(
                          cells: [
                            DataCell(Text(data['name'] ?? 'N/A')),
                            DataCell(Text(data['email'] ?? 'N/A')),
                            DataCell(Text(data['phone'] ?? 'N/A')),
                            DataCell(Text(data['logins'].toString())),
                            DataCell(Text(data['orders'].toString())),
                            DataCell(Text('Ksh ${data['totalSpent']}')),
                            DataCell(Text(data['registrationDate'])),
                            DataCell(Text(data['lastLogin'])),
                          ],
                        );
                      }).toList(),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}